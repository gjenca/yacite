<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
 <head>
  <meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
  <title>
   yacite command reference
  </title>
 </head>
<body>

<h1>
<tt>yacite</tt> command reference
</h1>
<p><strong>USAGE:</strong> <code>yacite append [-h] fieldname string [string ...]</code></p>
<p><strong>DESCRIPTION:</strong></p>
<p>appends all strings in the list to the value of a field</p>
<p><strong>POSITIONAL ARGUMENTS:</strong></p>
<blockquote>
<p><code>fieldname</code></p>
<blockquote>
<p>Field name. Value must be a 'list of strings'.</p>
</blockquote>
<p><code>string</code></p>
<blockquote>
<p>these strings are appended to the value</p>
</blockquote>
</blockquote><hr />
<p><strong>USAGE:</strong> <code>yacite delfields [-h] fieldname [fieldname ...]</code></p>
<p><strong>DESCRIPTION:</strong></p>
<p>reads YAML stream, deletes some fields, writes YAML stream</p>
<p><strong>POSITIONAL ARGUMENTS:</strong></p>
<blockquote>
<p><code>fieldname</code></p>
<blockquote>
<p>fields to delete</p>
</blockquote>
</blockquote><hr />
<p><strong>USAGE:</strong> <code>yacite exec [-h] [-n | -f] [-k] [-m MODULE] statement</code></p>
<p><strong>DESCRIPTION:</strong></p>
<p>execute a python statement on every record</p>
<p><strong>POSITIONAL ARGUMENTS:</strong></p>
<blockquote>
<p><code>statement</code></p>
<blockquote>
<p>python statement</p>
</blockquote>
</blockquote>
<p><strong>OPTIONAL ARGUMENTS:</strong></p>
<blockquote>
<p><code>-n, --no-output</code></p>
<blockquote>
<p>supress normal yaml output stream; any intended output must be preformed by statement itself</p>
</blockquote>
<p><code>-f, --failed</code></p>
<blockquote>
<p>output only the failed records,supress error messages</p>
</blockquote>
<p><code>-k, --keep-going</code></p>
<blockquote>
<p>do not stop when the statement throws an exception</p>
</blockquote>
<p><code>-m, --module MODULE</code></p>
<blockquote>
<p>python module to import; multiple -m options are possible</p>
</blockquote>
</blockquote><hr />
<p><strong>USAGE:</strong> <code>yacite filter [-h] [--myown] [--notmyown] [-f] [-m MODULE] [-k] expr</code></p>
<p><strong>DESCRIPTION:</strong></p>
<p>evaluates a python expression in the context of the each record,
    outputs records for which expression returns True</p>
<p><strong>POSITIONAL ARGUMENTS:</strong></p>
<blockquote>
<p><code>expr</code></p>
<blockquote>
<p>python expression</p>
</blockquote>
</blockquote>
<p><strong>OPTIONAL ARGUMENTS:</strong></p>
<blockquote>
<p><code>--myown</code></p>
<blockquote>
<p>filter applies only if myown == True, otherwise the record passes through</p>
</blockquote>
<p><code>--notmyown</code></p>
<blockquote>
<p>filter applies only if myown == False or undefined, otherwise the record passes through</p>
</blockquote>
<p><code>-f, --failed</code></p>
<blockquote>
<p>output only the failed records,supress error message</p>
</blockquote>
<p><code>-m, --module MODULE</code></p>
<blockquote>
<p>python module to import</p>
</blockquote>
<p><code>-k, --keep-going</code></p>
<blockquote>
<p>do not stop when the eval(expr) throws an exception</p>
</blockquote>
</blockquote><hr />
<p><strong>USAGE:</strong> <code>yacite checkdups [-h] fieldname [fieldname ...]</code></p>
<p><strong>DESCRIPTION:</strong></p>
<p>reads YAML stream, checks for duplicities, writes list of pairs of keys to stdout</p>
<p><strong>POSITIONAL ARGUMENTS:</strong></p>
<blockquote>
<p><code>fieldname</code></p>
<blockquote>
<p>fields to check for similarities</p>
</blockquote>
</blockquote><hr />
<p><strong>USAGE:</strong> <code>yacite merge [-h] [-u UNAME] [-s SNAME] [-d DNAME] [-v] [-b | -B] [-q]datadir</code></p>
<p><strong>DESCRIPTION:</strong></p>
<p>merge records with datadir - see the docs for merge rules</p>
<p><strong>POSITIONAL ARGUMENTS:</strong></p>
<blockquote>
<p><code>datadir</code></p>
<blockquote>
<p>data directory</p>
</blockquote>
</blockquote>
<p><strong>OPTIONAL ARGUMENTS:</strong></p>
<blockquote>
<p><code>-u, --union UNAME</code></p>
<blockquote>
<p>take union of lists - original and new</p>
</blockquote>
<p><code>-s, --set SNAME</code></p>
<blockquote>
<p>replace orginal values by new value</p>
</blockquote>
<p><code>-d, --delete DNAME</code></p>
<blockquote>
<p>delete these fields</p>
</blockquote>
<p><code>-v, --verbose</code></p>
<blockquote>
<p>be verbose</p>
</blockquote>
<p><code>-b, --bounced</code></p>
<blockquote>
<p>write bounced fields to a mergeable YAML stream</p>
</blockquote>
<p><code>-B, --strongly-bounced</code></p>
<blockquote>
<p>write strongly bounced fields to a mergeable YAML stream</p>
</blockquote>
<p><code>-q, --quiet</code></p>
<blockquote>
<p>be quiet</p>
</blockquote>
</blockquote><p><strong>HOW DOES THE MERGE COMMAND WORK:</strong></p>
<blockquote>
<p>merge means this:</p>
</blockquote>
<ul>
<li>for each <em>newrecord</em> in <em>stdin</em><ul>
<li>determine how many records in <em>datadir</em> are "very similar"
  to <em>newrecord</em>, that means
  one of the following:<ul>
<li>same key</li>
<li>same year,title,authors</li>
<li>same journal name,volume,startpage </li>
<li>same article-id</li>
</ul>
</li>
<li>if there is more than one record in datadir very similar to
  <em>newrecord</em>, then fail with an error.</li>
<li>if there is no record in datadir very similar to <em>newrecord</em>, then
  CREATE a new file as follows:<ul>
<li>generate a new key field in <em>newrecord</em> (if not present)</li>
<li>create a new file in datadir. The filename of the new file is <ul>
<li><em>datadir</em>/<em>year</em>/<em>key</em><code>.yaml</code>, if the boolean-valued 
  field <em>newrecord</em>[myown] is not true or not present</li>
<li><em>datadir</em>/myown/<em>year/</em>key<em><code>.yaml</code> if
<br />
</em>newrecord*<code>[myown]</code> is true.</li>
</ul>
</li>
</ul>
</li>
<li>if there is exacly one record in datadir very similar to
  <em>newrecord</em>, then UPDATE the matching record (called <em>match</em> from
  now on) in <em>datadir</em> with values from
  <em>newrecord</em> according to the following rules</li>
<li>for each <em>fieldname</em> in <em>newrecord</em><ul>
<li>if <em>fieldname</em> is not present in <em>match</em>, extend <em>match</em> by
  new <em>fieldname</em>=<em>fieldvalue</em></li>
<li>if <em>fieldname</em> is present in <em>match</em> but its values are the
  same in <em>newrecord</em> and in <em>match</em>, do nothing</li>
<li>if <em>fieldname</em> is present in match and its values are
  distinct if <em>newrecord</em> and in <em>match</em> then UPDATE the
  corresponding field in <em>match</em> according to the '-s', '-u'
  or '-d' options of the 'yacite merge' command, meaning this:<ul>
<li>if <em>fieldname</em> is one of the <em>SNAME</em>s, the set the value
    in <em>match</em> to the value in <em>newrecord</em></li>
<li>if <em>fieldname</em> is one of the <em>UNAME</em>s, then the values in
    botch <em>newrecord</em> and <em>match</em> must be of the type "list of
    something". The value in <em>match</em> is extended by the value
    in in <em>newrecord</em>.</li>
<li>if <em>fieldname</em> is one of the <em>DNAME</em>s, then the
    corresponding field in <em>match</em> is deleted.</li>
<li>if <em>fieldname</em> is not present in any of <em>UNAME</em> <em>SNAME</em>
    <em>DNAME</em>, then a warning is issued with level according to
    '-v' and '-q' options.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul><hr />
<p><strong>USAGE:</strong> <code>yacite read [-h] datadir</code></p>
<p><strong>DESCRIPTION:</strong></p>
<p>reads records from datadir, outputs them</p>
<p><strong>POSITIONAL ARGUMENTS:</strong></p>
<blockquote>
<p><code>datadir</code></p>
<blockquote>
<p>data directory</p>
</blockquote>
</blockquote><hr />
<p><strong>USAGE:</strong> <code>yacite render [-h] [-e EXTRA_YAML] [-k SORT_KEY] [-t TEMPLATE_DIR]template</code></p>
<p><strong>DESCRIPTION:</strong></p>
<p>renders records using a jinja2 template</p>
<p><strong>POSITIONAL ARGUMENTS:</strong></p>
<blockquote>
<p><code>template</code></p>
<blockquote>
<p>template file</p>
</blockquote>
</blockquote>
<p><strong>OPTIONAL ARGUMENTS:</strong></p>
<blockquote>
<p><code>-e, --extra-yaml EXTRA_YAML</code></p>
<blockquote>
<p>additional yaml to pass to template; the data is available as <code>extra</code> </p>
</blockquote>
<p><code>-k, --sort-key SORT_KEY</code></p>
<blockquote>
<p>either fieldname of ~fieldname (for citedby sorting)</p>
</blockquote>
<p><code>-t, --template-dir TEMPLATE_DIR</code></p>
<blockquote>
<p>directory with templates; default: ./templates</p>
</blockquote>
</blockquote><p><strong>implementation:</strong></p>
<blockquote>
<p>The render subcommand  produces the final result: the list of
citations. The data is passed to the jinja2 python library, which uses a
template to produce the list of citations. The jinja2 template language is
documented at the <a href="http://jinja.pocoo.org/docs/templates/">jinja2 site</a> .</p>
<p>Currently, the templates are expected to be in the subdirectory <code>templates</code>
of the current directory. You can use <code>#</code> as the prefix of jinja2 tag lines.
The environment passed to the template consists of
the following data:</p>
<p><code>records</code></p>
<blockquote>
<p>List of dictionaries, includes all of the data in the input YAML
stream. Additionally, the following data are computed/altered:</p>
<ul>
<li>in the input YAML the <code>cites</code> fields is expected to contain list of keys to
     <code>key</code>s of other records. The keys (i.e. strings) are replaced by
     records to the corresponding keys themselves.</li>
<li>in every record, a new <code>citedby</code> field is created. The field is a list of
     records that cite the current record via the <code>cites</code> field.</li>
</ul>
</blockquote>
<p><code>extra</code></p>
<blockquote>
<p>Some python data from the argument of the -e option.</p>
</blockquote>
</blockquote>
<p><strong>example template:</strong></p>
<pre><code># for bibrec in records
# if bibrec.myown
{{ bibrec.authors|join(", ") }}:{{bibrec.title}} {{bibrec.year}}
# if bibrec.citedby
Was cited by:
# for cit in bibrec citedby
  * {{ bibrec.authors|join(", ") }}:{{bibrec.title}} {{bibrec.year}}
# endfor
# endif
# endif
# endfor
</code></pre>
<p><strong> custom filters:</strong></p>
<blockquote>
<p><code>authorsformat(*bst-name-format*)</code></p>
<blockquote>
<p>expects list of authors, rewrites them according to given BibTeX style
name format string. See http://www.tug.org/TUGboat/tb27-2/tb87hufflen.pdf
for details.</p>
</blockquote>
</blockquote>
<p><strong> example usage in a template:</strong></p>
<pre><code>{{ rec.authors|authorsformat("{f. }{vv}{ll{ }}{, jj}")|join(", ") }}
</code></pre><hr />
<p><strong>USAGE:</strong> <code>yacite rewrite [-h] fieldname rewrite_file</code></p>
<p><strong>DESCRIPTION:</strong></p>
<p>rewrites values of a given field using a file with rewrite rules</p>
<p><strong>POSITIONAL ARGUMENTS:</strong></p>
<blockquote>
<p><code>fieldname</code></p>
<blockquote>
<p>field name</p>
</blockquote>
<p><code>rewrite_file</code></p>
<blockquote>
<p>file with rewrite rules - see the docs for format</p>
</blockquote>
</blockquote><p><strong>rewrite file format (YAML):</strong></p>
<blockquote>
<p>a list of pairs of strings</p>
</blockquote>
<pre><code>- [*pattern_string_1*,*replace_string_1*]
- [*pattern_string_2*,*replace_string_2*]
- ...
- [*pattern_string_n*,*replace_string_n*]
</code></pre>
<p><strong>example rewrite file</strong></p>
<pre><code>- ["Jenca","Jenča"]
- ["Kuhr","Kühr"]
- ["Kuehr","Kühr"]
</code></pre><hr />
<p><strong>USAGE:</strong> <code>yacite sort [-h] [-k SORT_KEY]</code></p>
<p><strong>DESCRIPTION:</strong></p>
<p>sorts the records in input stream according to given fields</p>
<p><strong>OPTIONAL ARGUMENTS:</strong></p>
<blockquote>
<p><code>-k, --sort-key SORT_KEY</code></p>
<blockquote>
<p>either fieldname of ~fieldname</p>
</blockquote>
</blockquote><hr />
<p><strong>USAGE:</strong> <code>yacite unappend [-h] fieldname string [string ...]</code></p>
<p><strong>DESCRIPTION:</strong></p>
<p>deletes each string in the list from the list of strings in the value of a field</p>
<p><strong>POSITIONAL ARGUMENTS:</strong></p>
<blockquote>
<p><code>fieldname</code></p>
<blockquote>
<p>Value of the field must be 'list of strings'.</p>
</blockquote>
<p><code>string</code></p>
<blockquote>
<p>these strings are removed from the value, if present</p>
</blockquote>
</blockquote><hr />
</body>
</html>
