<!---
vim:ft=markdown
-->

<h1><code>yacite</code> tutorial</h1>
<h2>Motto</h2>
<blockquote>
<p>This is the Unix philosophy: Write programs that do one thing and do it well.
Write programs to work together. Write programs to handle text streams,
because that is a universal interface.</p>
<p>Bell Laboratories. M. D. McIlroy, E. N. Pinson, and B. A. Tague.  “Unix
Time-Sharing System Forward”. <em>The Bell System Technical Journal</em> 1978.
<strong>57</strong> (6, part 2). p. 1902.</p>
</blockquote>
<h2>What is <code>yacite</code></h2>
<p><code>yacite</code> is a system commandline UNIX utilities to solve the following tasks:</p>
<ol>
<li>Keeping track of scientific papers written by a single author or a small
    group.</li>
<li>Keeping track of citations of one's papers.</li>
<li>Simple filtering, automatic manipulation, tagging etc. of
    bibliographic records.</li>
<li>Rendering subsets of bibliographic data in HTML or other text-based form.</li>
</ol>
<h2>Lesson 1: Creating HTML list of your publications</h2>
<ol>
<li>
<p>Open a terminal emulator and type the following commands on the shell
    prompt</p>
<pre><code>mkdir yacite_sandbox
cd yacite_sandbox
</code></pre>
<p>This creates a new working directory. </p>
</li>
<li>
<p>You will need a BibTeX ('.bib') database file containing your publications.
    You can download it from a bibliographic database like Scopus of Web of
    Science or Google Scholar. Save the file (let us call it <code>mypubs.bib</code>) in the
    <code>yacite_sandbox</code> directory you created.</p>
</li>
<li>
<p>Go back to the shell prompt (the current directory should be <code>yacite
    sandbox</code> and type the following command </p>
<pre><code>bib2yaml mypubs.bib
</code></pre>
<p>This command prints on its standard output a series of records in YAML
format, we call this <em>a YAML stream</em>. A YAML stream consists of a sequence
of records that look like this:</p>
<pre><code>authors: ['Jenča, Gejza']
doi: 10.1007/s00500-012-0901-x
endpage: 47
grants: VEGA G-2/0059/12, VEGA G-1/0297/11, APVV-0073-10, APVV-0178-11
issn: 1432-7643
issue: 1
journal: Soft Computing
keywords: Effect algebra; Lattice effect algebra; Compatibility center
publisher: Springer-Verlag
startpage: 45
tags: [zpub, sci, cc, scopus]
title: Congruences generated by ideals of the compatibility center of lattice efect algebras
type: article
url: http://dx.doi.org/10.1007/s00500-012-0901-x
volume: 17
year: 2013
</code></pre>
<p>The records in the YAML stream are separated by triple minus <code>---</code>. </p>
<p>Unlike BibTeX, YAML is a popular way to represent data in the current world of
computing. Probably in every programming language, there is a library to
read and write YAML data. Unlike other serialization formats (like
XML), the YAML format was designed to be both human-readable and
human-editable. It can be edited using any text editor.
1.  What we want to do now is to convert a YAML stream into a HTML document.
This is accomplished using a <em>template</em>. A HTML template is a HTML file
containing special non-HTML control sequences 
representing variables, loops, conditions
etc. <code>yacite</code> uses the jinja2 template language.</p>
<p>The templates are kept in a separate directory. Create the
directory on the command prompt:</p>
<pre><code>mkdir templates
</code></pre>
<p>To keep things simple, we shall create a very simple template. Open your
favorite text editor and type in the following jinja2 code.</p>
<pre><code>&lt;html&gt;
&lt;body&gt;
&lt;h1&gt;List of publications&lt;/h1&gt;
&lt;ol&gt;
# for rec in records:
&lt;li&gt;
{{  rec.authors|join(", ") }}
&lt;em&gt;{{rec.title}}&lt;/em&gt;,
{{rec.journal}},
&lt;strong&gt;{{rec.volume}}&lt;/strong&gt;
({{rec.year}})
{{rec.startpage}}-{{rec.endpage}}
&lt;/li&gt;
# endfor
&lt;/ol&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>This is pretty much self explanatory. The jinja2 commands start with <code>#</code>.
The variables are enclosed in double curly brackets. The construction</p>
<pre><code>{{  rec.authors|join(", ") }}
</code></pre>
<p>means that the authors should be separated by a comma and a space.
1.  Save the template under some name, let us say <code>publist.html</code> in the
<code>templates</code> directory.
1.  Type in the following command on the shell prompt.</p>
<pre><code>bib2yaml mypubs.bib | yacite render publist.html
</code></pre>
<p>This is called a <em>pipe sequence</em>. The whole <code>yacite</code> system is based
on pipe sequences. There are two commands at work here. The <code>bib2yaml</code>
command produces a YAML stream as its output. The <code>|</code> sign (called
<em>pipe</em>) in the middle connects the output of the <code>bib2yaml</code> command
and with the input of the other command, <code>yacite render</code>.  The <code>yacite
render</code> command reads a YAML stream on its input, fills in the
template, and then produces HTML on its output. </p>
<p>There are more things that <code>yacite render</code> does (like dealing with
citations) but, for the moment, we do not care.
1.  Save the resulting HTML into a file using the redirect sign <code>&gt;</code> :</p>
<pre><code>bib2yaml mypubs.bib | yacite render publist.html &gt; mypubs.html
</code></pre>
<p>and open the <code>mypubs.html</code> in you favourite browser. Enjoy the result. 
1.  Try to alter the
template; for example, change the <code>&lt;ol&gt;</code> and <code>&lt;/ol&gt;</code> tags to <code>&lt;ul&gt;</code>
and <code>&lt;/ul&gt;</code>, respectively, and observe the results in <code>mypubs.html</code>. 
Note that you need to click the reload button in your browser to see the 
updates in a HTML document.
1.  If you need to create a MS Word document, there are some ways how to convert a
simple HTML document to a <code>.doc</code> file. For example, you can try the
excellent <code>pandoc</code> document conversion utility. In addition, as I was
told, MS Word should be capable to load a HTML file and save it as a
MS Word file.</p>
</li>
</ol>
<h2>Lesson 2: Filtering the YAML stream</h2>
<ol>
<li>
<p>Try the following command</p>
<pre><code>bib2yaml mypubs.bib | yacite filter 'year == 2012'
</code></pre>
<p>Note that the argument of the <code>yacite filter</code> command in enclosed in
apostrophes. This tell the shell to pass it to the <code>yacite</code> as a
single argument.  The argument <code>year == 2012</code> is a Python expression.</p>
<p>The result should be a filtered YAML stream that contains only the
2012 publications. </p>
<p><strong>Explanation:</strong> The <code>yacite filter</code> command evaluates the <code>year == 2012</code>
expression in the environment given by the record in stream. If the
expression is true, the records is outputted, otherwise it is skipped.</p>
<p>You can now try create a HTML document using <code>yacite render</code>, as in
the previous example.</p>
<pre><code>bib2yaml mypubs.bib | yacite filter 'year == 2012' | yacite render publist.html &gt; mypubs_2012.html
</code></pre>
</li>
<li>
<p>Alter the argument of <code>yacite filter</code> as follows:</p>
<pre><code>bib2yaml mypubs.bib | yacite filter '"the" in title' | yacite render publist.html &gt; mypubs_the.html
</code></pre>
<p>This should create a list of publications containg 'the' as a
substring of the title.</p>
</li>
<li>
<p>You can use conjunction (<code>and</code>), disjunction (<code>or</code>), negation (<code>not</code>):</p>
<pre><code>... yacite filter '("Fourier" in title) or "(Laplace" in title)' ...
... yacite filter '(year &gt; 2000) and (year &lt;= 2010)' ...
... yacite filter 'not ("semigroup" in keywords)' ...
</code></pre>
<p>The last command is equivalent to much more
readable</p>
<pre><code>... yacite filter '"Effect" not in keywords' ...
</code></pre>
<p>We refer to Python tutorial for more information about Python
expressions.</p>
</li>
</ol>
<h2>Lesson 3: Persistence: saving the data into database directory</h2>
<ol>
<li>
<p>In <code>yacite</code>, data are saved in plain YAML documents, one record per
    file. The documents are saved in a database directory, called <em>datadir</em>. 
    Currently, datadir simple and allows for editing the
    data in place using any text editor, since there are no metadata.</p>
<p>Create the datadir:</p>
<pre><code>mkdir pubcit
</code></pre>
<p>The name of the datadir does not matter at all.
1.  The command <code>yacite merge</code> reads the YAML stream from its input
and saves the individual records in the datadir.</p>
<pre><code>bib2yaml mypubs.bib | yacite merge pubcit
</code></pre>
<p>You see a couple of log messages saying that some new records were
created. Go into the <code>pubcit</code> directory and look around. There is 
a couple of files with the name scheme</p>
<p><code>pubcit/${YEAR}/${AUTHOR}${YEAR}${TITLEWORD}.yaml</code></p>
<p><code>${AUTHOR}</code> is the surname of the first author.
<code>${TITLEWORD}</code> is the first word in the title, unless it is too short,
like "a" or "the". In this case, <code>${TITLEWORD}</code> are first two word of
the title. The name scheme makes it easy to find individual records.</p>
<p>When you open one the files you in a text editor can see that in every
file a new field <code>key</code> was created. The value of <code>key</code> is
<code>${AUTHOR}${YEAR}${TITLEWORD}</code>. It is easy to infer the value of <code>key</code>
from the basic bibliographic data of the paper.
1.  Sometimes, there are multiple records with the same first author, year
and the first word of the title. Whenever this happens, a suffix <code>-1</code> (or
more) is appended to <code>key</code> and to the corresponding part of the
filename.
1.  Try again the command </p>
<pre><code>bib2yaml mypubs.bib | yacite merge pubcit
</code></pre>
<p>Hopefully, nothing happens.  For every record on its input, <code>yacite
merge</code> figured out using a heuristics that the record on its input
points (in the real world) to the same article as the one stored in
the database. Since every filed value in the input record (except for
the <code>key</code>, which is ignored in this respect) is the same as the stored
one, there nothing to do and the stored record is unchanged.</p>
</li>
</ol>
<h2>Lesson 4: Marking the records as your own</h2>
<ol>
<li>
<p>Let us start with a clean table. Remove the datadir and start with an
    empty one.</p>
<pre><code>rm -rv pubcit
mkdir pubcit
</code></pre>
</li>
<li>
<p>Try this command</p>
<pre><code>bib2yaml mypubs.bib | yacite exec 'myown=True'
</code></pre>
<p>The result is an altered YAML stream. There is a new field,
<code>myown</code> with value <code>true</code> in every record. Note the difference;
<code>True</code> is a Python constant, <code>true</code> is a YAML constant. Also,
there is a single <code>=</code>, not <code>==</code>; we are assigning a value, not making
a comparision.</p>
<p><strong>Explanation:</strong> The <code>yacite exec</code> command executes the Python command 
(in this case, <code>myown=True</code>) in the environment given by the record in stream. 
The transformed records are written to the standard output of <code>yacite
exec</code> as a YAML stream.
1.  Now let the altered YAML stream flow into the <code>yacite merge</code> command:</p>
<pre><code>bib2yaml mypubs.bib | yacite exec 'myown=True' | yacite merge pubcit
</code></pre>
<p>Note that the filenames are different now: every new file is placed
into a <code>myown</code> subdirectory. This allows one to easily find his/her
own records.</p>
</li>
</ol>
<h2>Lesson 5: Reading the database directory</h2>
<ol>
<li>
<p>The command <code>yacite read</code> reads all data in the datadir and outputs
    them as a YAML stream:</p>
<pre><code>yacite read pubcit
</code></pre>
<p>You can render the stream using a template:</p>
<pre><code>yacite read pubcit | yacite render publist.html &gt; out.html
</code></pre>
<p>Try to put some <code>yacite filter</code> in the middle of the pipe sequence
and look at the result.</p>
</li>
</ol>
<h2>Lesson 6: Tagging the records in the database directory</h2>
<ol>
<li>There are two ways how to update records in the datadir: either direct
    editing or via the <code>yacite merge</code> command. Direct editing should be
    clear: just edit the files using any text editor. This is aprropriate
    for individual changes.</li>
<li>
<p>Let us supose we that all the data in datadir were created from
    SCOPUS. We would like to mark them as such. One of the possibilities
    would be to add a boolean variable <code>scopus</code> in every record, as we
    did with <code>myown</code> in one of the above examples.</p>
<pre><code>yacite read pubcit | yacite exec 'scopus=True' | yacite merge pubcit
</code></pre>
<p>However, this is not necessarily a good idea, because, for example,
it is not clear from looking at the data which fields are "real data"
and which are "custom marks". It is better to equip
every record with a list of strings, let us say <code>tags</code>. There is a
special pair of commands for manipulation with lists of strings,
namely <code>yacite append</code> and <code>yacite unappend</code>. Look at the output of
this command:</p>
<pre><code>yacite read pubcit | yacite append tags scopus
</code></pre>
<p>There is <code>tags: [scopus]</code> in every record in the resulting YAML stream.
Let the stream flow back into the database:</p>
<pre><code>yacite read pubcit | yacite append tags scopus | yacite merge pubcit
</code></pre>
<p>The merge command displays a couple of log messages about creating new
<code>tags</code> fields for every record in the database. 
1.  Let us mark the records older than 2005 as old. This can be done using
sequence of filtering and marking: </p>
<pre><code>yacite read pubcit | yacite filter 'year&lt;2005' | yacite append tags old
</code></pre>
<p>This works as expected, the resulting YAML stream contains either '[scopus,old]'
or '[scopus]' as the value of 'tags', depending of the value of year. However,  </p>
<pre><code>yacite read pubcit | yacite filter 'year&lt;2005' | yacite append tags old | yacite merge pubcit
</code></pre>
<p>produces a message about "bounced" fields. To see what
happened, try the '-v' option (v is for verbose):</p>
<pre><code>yacite read pubcit | yacite filter 'year&lt;2005' | yacite append tags old | yacite merge -v pubcit
</code></pre>
<p>Every changed <code>tags</code> field bounced. What happened? The <code>yacite merge</code>
command recognized that the records in the YAML stream are new
versions of the records in the database and that the value of <code>tags</code>
is different. <code>yacite merge</code> is careful, it does not change existing
data in the database unless explicily said to do so.
And did not say what to do with the changed value of <code>tags</code>. What
we want to do is to set <code>tags</code> to the new value. This command
does the trick:</p>
<pre><code>yacite read pubcit | yacite filter 'year&lt;2005' | yacite append tags old | yacite merge -s tags pubcit
</code></pre>
<p>The <code>-s tags</code> (s stands for SET) says that the value of <code>tags</code> should
be updated to the value obtained from the YAML stream.</p>
</li>
<li>
<p>Let us delete the 'old' tag (it was a silly example anyway).</p>
<pre><code>yacite read pubcit | yacite unappend tags old
</code></pre>
<p>shows a YAML stream without any <code>old</code> tag among <code>tags</code>. The rest of
the task of deleting the <code>old</code> tag is left as an exercise to the
esteemed reader.  </p>
</li>
</ol>
<h2>Lesson 7: Merging data from different sources</h2>
<ol>
<li>
<p>Let us start with a clean database again:</p>
<pre><code>rm -r pubcit
mkdir pubcit
</code></pre>
</li>
<li>
<p>We assume in this lesson that we have two BibTeX files containing
    bibliography data concerning your own articles, the names of the files
    are <code>scopus.bib</code> and <code>wos.bib</code>. Merge the data from the <code>scopus.bib</code>
    into the database, marking them with <code>scopus</code> tag and <code>myown=true</code> in
    each record.</p>
<pre><code>bib2yaml scopus.bib | yacite append tags scopus | yacite exec 'myown=True' | yacite merge pubcit
</code></pre>
</li>
<li>
<p>Take the other file, <code>wos.bib</code> and do the same thing with it, use the
    <code>-v</code> (verbose) option with yacite merge.</p>
<pre><code>bib2yaml wos.bib | yacite append tags wos | yacite exec 'myown=True' | yacite merge -v pubcit
</code></pre>
<p>What happened? Examine the messages given by <code>yacite merge</code>.</p>
<ol>
<li>If there are some records that are in <code>wos.bib</code> and not in
    <code>scopus.bib</code>, they were new so the <code>yacite merge</code> did the
    right thing: it created new records. These are exactly the
    records that are in <code>wos.bib</code> and not in <code>scopus.bib</code>.
    Their value of <code>tags</code> is <code>[wos]</code>.</li>
<li>For the records that are in both BibTeX files, there were some
    new fields present in YAML stream.  These were appended to the
    corresponding records.</li>
<li>A lot of fields "bounced". That means that they were present
    in both records, but their values were different. It is for
    sure that the field <code>tags</code> is amoung the bounced fields, since
    its value is <code>[scopus]</code> in the database and <code>[wos]</code> in the
    YAML stream. It is possible that the other fields differ as
    well, mostly <code>title</code>, <code>journal</code>, <code>authors</code> and others.
    Probably the only difference is the capitalization and whether
    the authors field contains full names. </li>
</ol>
</li>
<li>
<p>What we need to do now, is to set the value of the field <code>tags</code> in a
    record in the database to <code>[scopus, wos]</code> for every record in the
    database that matched a record in the YAML stream originated; these
    are the records that are in both <code>wos.bib</code> and <code>scopus.bib</code>. For each
    matching pair of records, the record in the YAML stream has
    <code>tags: [wos]</code> and the record in the database has <code>tags: [scopus]</code>.
    So we instruct <code>yacite merge</code> to make a union (<code>-u</code>) of the value of
    <code>tags</code>:</p>
<pre><code>bib2yaml wos.bib | yacite append tags wos | yacite exec 'myown=True' | yacite merge -v -u tags pubcit
</code></pre>
</li>
</ol>
<h2>Lesson 8: Dealing with bounced fields</h2>
<ol>
<li>
<p>When merging data from different sources, it is often necessary to
    deal with the fact that the fields that (ideally) should have the same
    value are, in fact different. Examples follow.</p>
<ul>
<li>The first name of one of the authors is (not) given.</li>
<li>The capitalization in title differs.</li>
<li>The capitalization in journal or series name differs.</li>
<li>The name of the journal contains a subtitle.</li>
</ul>
<p>The <code>yacite merge</code> command detects that the fields are different, but it
does not do anything about it without an user intervention.
1.  Try the following command:</p>
<pre><code>bib2yaml wos.bib | yacite append tags wos | yacite exec 'myown=True' | yacite merge -b -u tags pubcit &gt; diff.yaml
</code></pre>
<p>You should see a short message about the number of bounced
fields/records. Open the file <code>diff.yaml</code> in a text editor. For every
record that has at least one bounced field, it contains the following
data:</p>
<ul>
<li>The <code>key</code> field of the record in the database. This allows to
    identify the database record unambigously.</li>
<li>The names and values from the input YAML stream that bounced.</li>
<li>The field names and values of the bounced fields that are
    present in the database are given in a remark. This allows you
    to compare the old value with the new one to decide which one
    is better.</li>
</ul>
<p>So now you could open the corresponding database file in a text editor
and copy/paste the values from <code>diff.yaml</code>, right? Wrong!</p>
<p>The key point is that the file <code>diff.yaml</code> now contains a <em>mergeable
YAML stream!</em>. So the following command is legal, but has no effect on
the database:</p>
<pre><code>yacite merge pubcit &lt; diff.yaml
</code></pre>
<p>If you edit the <code>diff.yaml</code> so that it contains only the fields that
are "better" in <code>diff.yaml</code> than in the database, you can tell <code>yacite
merge</code> to rewrite the field with the new value. This is the right way
to deal with the problem of bounced fields.</p>
<p>For example:</p>
<ol>
<li>Pick some important field, let us say <code>authors</code></li>
<li>Delete every line <code>authors:...</code> in <code>diff.yaml</code> where the value
    in <code>diff.yaml</code> is "worse" than the one in the database.</li>
<li>
<p>Use the following command (note that the output goes to a
    different file than <code>diff.yaml</code>)</p>
<pre><code>yacite merge -b -s authors pubcit &lt; diff.yaml &gt; diff2.yaml
</code></pre>
<p>The <code>-s authors</code> means: SET <code>authors</code> to the new value.
    1.  Look at the message: the value of <code>authors</code> was updated in the
database. The <code>diff2.yaml</code> file contains remaining bounced
fields.
    1.  Repeat for another field you consider important.</p>
</li>
</ol>
<p>Of course, you can edit all the fields at once and then merge them
with a single <code>yacite merge</code> command; there can be multiple <code>-s</code>
options when doing a merge.</p>
</li>
</ol>
<h2>Lesson 8: Adding citations -- per cited article</h2>
<ol>
<li>Let us assume you already managed to register all of your own papers in the
    database. Now go to the citation database, for example SCOPUS and export all
    citations of <em>one</em> of your papers to a file, let us say <code>citations.bib</code>.</li>
<li>
<p>Let us say that the <code>key</code> of your paper is <code>yourname2012aword</code>. Run
    the following command to merge the citations.</p>
<pre><code>bib2yaml citations.bib | yacite append cites yourname2012aword | yacite append tags scopus | yacite merge -u cites -u tags pubcit
</code></pre>
</li>
<li>
<p>Repeat for all of your papers. Maybe you have to deal with some
    bounces, especially when you use multiple citation databases.</p>
</li>
<li>This workflow is more effective for creating the initial database of
    citations,simply because the number of cited papers is probably
    smaller than the number of citing papers.</li>
</ol>
<h2>Lesson 9: Adding citations -- per citing article</h2>
<ol>
<li>There is another type of workflow for adding citations, probably more
    effective for updating the database with new citing papers.</li>
<li>Export the bibliographic data of the new citing papers to a file, say
    <code>newcites_scopus.bib</code>.</li>
<li>
<p>Convert the file to yaml:</p>
<pre><code>bib2yaml newcites_scopus.bib | yacite append tags scopus |
yacite exec 'cites=[]' &gt; newcites_scopus.yaml
</code></pre>
<ol>
<li>
<p>Edit the <code>newcites_scopus.yaml</code> file. Fill the value of the cites
field with corresponding keys of your articles. Then, merge the
edited file:</p>
<p>yacite merge -u tags -u cites &lt; newcites_scopus.yaml</p>
</li>
</ol>
</li>
</ol>
<h2>Lesson 10: Rendering citation lists</h2>
<ol>
<li>
<p>We already know how to represent citations. How do we get the
    information in a presentable form? Using a jinja2 template, of course.
    This is a snippet of the HTML template I use, I call it
    <code>pubcitlist.html</code>. Recall that default location of templates is the <code>template</code>
    subdirectory.</p>
<pre><code>&lt;html&gt;
&lt;body&gt;
# for rec in records:
# if rec.myown
  # if rec.citedby:
  &lt;h3&gt;Paper:&lt;/h3&gt;
  &lt;p&gt;
  {{  rec.authors|join(", ") }}:
  &lt;em&gt;{{rec.title}}&lt;/em&gt;,
  {{rec.journal}},
  &lt;strong&gt;{{rec.volume}}&lt;/strong&gt;
  ({{rec.year}})
  {{rec.startpage}}-{{rec.endpage}}
  &lt;/p&gt;
  &lt;h3&gt;
  Cited in:
  &lt;/h3&gt;
  &lt;ol&gt;
  # for rec_cited in rec.citedby:
    &lt;li&gt;
    {{  rec_cited.authors|join(", ") }}:
    &lt;em&gt;{{rec_cited.title}}&lt;/em&gt;,
    # if rec_cited.journal:
    {{rec_cited.journal}},
    # endif
    # if rec_cited.series:
    {{rec_cited.series}},
    # endif
    &lt;strong&gt;{{rec_cited.volume}}&lt;/strong&gt;
    ({{rec_cited.year}})
    {{rec_cited.startpage}}-{{rec_cited.endpage}}
    # if "as-preprint" in rec_cited.tags:
    (cited as preprint)
    # endif
    &lt;/li&gt;
  # endfor
  &lt;/ol&gt;
  &lt;hr&gt;
  #endif
# endif
# endfor
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>There are two cycles in the template: the outer cycle runs through all
records, but it considers only those that have <code>myown = true</code> and are
cited at least once. For each such record <code>rec</code>, the inner cycle runs
through all records in <code>rec.citedby</code>; this is a list of records that
is <em>dynamically generated</em> by the <code>yacite render</code> command.</p>
</li>
<li>
<p>To render a subset of the citations, all you have to do is
    to use a <code>yacite filter</code>.
    A couple of examples follow.</p>
<p>Render all citations of all my papers in the database:</p>
<pre><code>yacite read pubcit | yacite render pubcitlist.html &gt; out.html
</code></pre>
<p>Render all citations of my papers from 2012 in the database</p>
<pre><code>yacite read pubcit | yacite filter --myown 'year==2012' |
yacite render pubcitlist.html
</code></pre>
<p>Render all citations from 2012 of all my papers in the database</p>
<pre><code>yacite read pubcit | yacite filter --notmyown 'year==2012' |
yacite render pubcitlist.html
</code></pre>
<p>So <code>--myown</code> restricts the filtering expression only to records with
<code>myown = true</code>, the others (with <code>myown = false</code> of without <code>myown</code>)
pass through the <code>yacite filter</code> unconditionally. Similarly for
<code>--notmyown</code>.</p>
</li>
</ol>
<h2>Lesson 11: What now?</h2>
<ol>
<li>Well, you should read the reference, there is a couple of commands and
    a lot of options that were not described in this tutorial. Figure out
    the workflow that suits you best.</li>
<li>
<p>You should read the template documentation in the jinja2 home page: [http://jinja.pocoo.org/docs/] .</p>
<p>Jinja2 can do a <em>lot</em> for you.
1.  Maybe you need a little bit of Python -- to write the more elaborated
filters and execs. Python docs are at
[http://docs.python.org/2/].</p>
</li>
</ol>